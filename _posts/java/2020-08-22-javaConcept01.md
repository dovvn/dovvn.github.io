---
title:  "[Java]"
excerpt: "Java 개념 총정리 01"
permalink: /categories/java/java-Concept01
author_profile: true
categories:
  - Java
toc: true
toc_label: "목차"
toc_icon: "bookmark"
last_modified_at: 2020-08-22
---

자바 공부를 하면서 새로 알게된 개념 & 꼭 필요한 개념 위주로 정리하였음.  

<br/>

# 1. JAVA 배경 지식
## Java의 특징
Write Once, Run Anywhere  
* 자바는 JVM하고만 상호작용을 하기 때문에 OS와 하드웨어에 독립적이라 다른 OS에서도 변경 없이 실행 가능하다. 즉, JVM이 설치된 환경 어느곳이든 동작할 수 있다(크로스 플랫폼)

## Eclipe
Java개발의 대표적인 IDE이며 컴파일, 디버깅, 빌드등의 개발 전체 과정을 편리하게 관리해준다.

## Java 개발환경 구축하기
JDK, IDE다운로드 후 환경변수 설정(JAVA_HOME, Path) 해주고 이클립스 탭메뉴 Preference-Encoding검색하고 utf-8로 변경, html,css,jsp,xml모두 utf-8로 변경
* JDK(Java Development Kit): JVM + JRE, 자바 개발하는데 필요한 프로그램으로 구성
* JVM(Java Virtual Machine): 자바를 실행하기 위한 가상 기계
* JRE(Java Runtime Environment): 자바 실행 환경, 자바로 작성된 프로그램이 실행되기 위한 최소환경

## [Java API 문서](https://docs.oracle.com/javase/8/docs/api/)
클래스 라이브러리의 모든 클래스에 대한 설명이 자세하게 나와 있다.
자바의 사전이라고 생각하면 된다.

## Java 컴파일 과정
Hello.java →(javac.exe 컴파일)→ Hello.class 생성 → (java.exe 실행) → "Hello.world" 출력

<br/>

# 2. 변수
## 변수의 타입
### 1. 기본형(Premitive Type)
실제값을 스택(비싸다, 가깝다)에 저장한다.   
선언하는 동시에 사이즈가 이미 정해져있다.    
종류는 총 8가지가 있다.  
![variable-type](/assets/images/variable-type.png)    

### 2. 참조형(reference Type)
가변적인 공간을 차지한다.
크기가 크기 때문에 별도로 힙(싸다, 멀다)이라는 메모리 공간에 실제 값을 저장하고, 이 주소를 스택에 있는 참조변수에 저장해서 실제 값에 접근한다.

![stringobj](/assets/images/stringobj.png)  
```java
String s1 = "hello";
String s2 = "hello";
String s3 = new String("hello");
String s4 = new String("hello");
System.out.println(s1 == s2);
```
`==`는 두 변수의 메모리 값을 비교한다.  
s1과 s2는 힙의 같은 문자열을 참조하고 있으므로 저장하고 있는 주소값이 같기 때문에 `s1 == s2`는 `true`이다.  
반면에 s3와 s4는 new로 만들어진 다른 문자열을 각각 참조하고 있으므로 저장하고 있는 주소값이 다르기 때문에 `s1 == s2`는 `false`이다.  
문자열의 내용이 같은지 확인하려면 `equals()`를 이용한다.


## 형변환(Type-Casting)
변수 또는 상수의 타입을 다른 타입으로 변환하는 것  
* 작은 타입에 큰 타입으로의 변환은 오류가 발생한다.  
* 정수형은 실수형으로 자동으로 형변환된다.  
* `char타입`은 문자의 유니코드(정수)가 저장되므로 int형에서 char형, char형에서 int형으로 형변환하게 되면 아스키코드표를 기준으로 변환한다.
* boolean을 제외한 나머지 7개 기본형은 서로 형변환이 가능하다.
* 기본형과 참조형은 서로 형변활할 수 없다.

<br/>

#  3. 연산자
연산을 수행하기 위한 기호로 연산을 수행하기 위해서는 반드시 피연산자가 필요하다.  
![operator](/assets/images/operator.png)  

## 비트연산자
피연산자를 비트단위로 논리 연산하며 피연산자로 오로지 정수만 올 수있다.   
피연산자를 이진수로 표현했을 때 |,&,^의 규칙에 따라 연산을 수행한다.  

* I(OR연산자): 피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 이 외에는 0을 얻는다.  
* &(AND연산자): 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다.  
* ^(XOR연산자): 피연산자의 값이 서로 다를 경우에만 1을 결과로 얻는다. 같을때는 1을 얻는다.  
* ~(비트전환연산자): 피연산자를 ~로 표현했을 때, 0은 1로 1은 0으로 바꾼다. 논리부정연산자 '!'와 유사하다.
* <<, >>(쉬프트연산자): 피연산자의 각 자리를 왼쪽(<<)또는 오른쪽(>>)으로 이동한다. 예를 들어 `8<<2`는 피연산자인 10진수 8의 2진수를 왼쪽으로 2자리 이동한다. 이동 후 범위를 벗어난 값은 버려지고, 빈자리는 0으로 채워진다.
* (비교) >>>: 부호를 신경쓰지 않고 오른쪽으로 이동한다.

## 조건연산자 ? :
조건식, 식1, 식2 모두 세개의 피연산자를 필요로 하는 삼항 연산자이다.  
조건식이 true이면 식1이 false이면 식2가 연산 결과가 된다.
```java
result = x > 0 ? 1 : (x == 0 ? = : -1) //이런식으로 중첩 가능
```

<br/>

# Math.random()
0부터 1 **사이**의 랜덤한 실수값을 출력한다.

<br/>

# 4. 배열
**같은 타입**의 여러 변수를 묶음으로 다루는 것
```java
int[] arr; //배열 다루기 위한 참조변수 선언
arr = new int[3]; //실제 저장공간 생성 

int[] arr1 = {1,2,3}; //한줄로 써줘야지 위처럼 두줄로 나누면 에러

int[] arr2 = new int[3];
```

## for each문
**읽기 전용**으로 배열 원소 값을 변경할 수 없다.
```java
int[] arr = {1,2,3};
for(int i : arr) System.out.print(i+" ");//1 2 3
```

## 배열의 복사
배열은 한번 생성하면 그 길이를 변경할 수 없다.(immutable)  
따라서 기존 배열을 기준으로 새로운 배열을 만들고 싶을 때 `System.arraycopy()`를 사용한다.  

```java
int[] arr = {1,2,3};
int[] arr2 = new int[3];
System.arraycopy(arr, 0, arr2, 0, 3); //(기존 배열, 기존 배열 시작 인덱스, 새로운 배열, 새로운 배열 시작 인덱스, 복사할 길이)
```

## 2차원 배열
2차원 배열에서는 마지막 차수의 길이를 지정하지 않고, 추후에 각기 다른 배열을 생성함으로써 가변적인 배열을 생성할 수 있다.  
```java
int[][] arr = new int[5][];
```

<br/>

# 5. 객체지향(OOP)
## 객체지향 특징 4가지
1. 캡슐화(정보은닉) Encapsulation(Information Hiding)
외부로 부터 데이터를 보호하기 위해서 또는, 내부적으로만 사용되는 멤버들을 클래스 내부에 감추기 위해서 `접근제어자`를 사용한다.  

* 접근제어자를 이용한 캡슐화 - setters와 getters
클래스의 `멤버변수`는 `private`으로 제한하고 멤버변수의 값을 읽고 변경할 수 있는 `public 메소드`를 만들어서 멤버변수의 값을 간접적으로 다룰 수 있도록 한다.  
멤버변수에 접근하기 위해서는 클래스 외부에서 `인스턴스`를 생성한 후, public으로 만든 setter()메서드로 값을 변경하고 값을 가져오고 싶을 경우 public으로 만든 getter()메서드를 사용한다.

```java
Tv tv = new Tv();
tv.getPrice(); //가격변수 가져오기
tv.setPrice(5000); //가격변수 변경하기
```

2. 상속 Inheritance
3. 다형성 Polymorphism
4. 추상화 Abstraction

## 클래스와 객체 
1. 클래스
* 현실 세계의 Object들을 분석해서 비슷한 것 끼리 묶어 분류한 것이다.    
다른 정의로는 객체를 만들기 위한 설계도이다. 필드부분(멤버변수)와 메소드 부분으로 설계된다.       
2. 객체    
* 클래스에 정의된 내용대로 메모리에 실제 생성된 것이다.  
* 객체는 클래스의 `인스턴스`라고 부른다.  
* 인스턴스는 `참조변수`를 통해서만 다룰 수 있으며 참조변수의 타입은 인스턴스의 타입과 일치해야한다. 

```java
Tv t; //Tv클래스 타입의 참조변수 t를 선언
t = new TV(); //Tv인스턴스를 생성 후 new연산자의 결과로 Tv인스턴스의 주소가 반환되어 t에 저장한다.
```

## 객체 배열
많은 객체를 다룰 때 사용하며 객체 배열안에 객체의 주소가 저장된다.  

![arrayObject](/assets/images/arrayObject.png)  

```java
Tv[] tvArr = new Tv[3]; //길이가 3인 Tv타입의 참조변수 배열

//아직 객체가 저장되지 않았다!
for(int i=1; i<-=tvArr.length; i++>{
    tvArr[i] = new tvArr(); //★객체를 생성해서 배열의 각 요소에 저장한다.
    tvArr[i].setPrice(i * 2000);
})
```
`다형성`에 의해 하나의 배열로 여러 종류의 객체를 다룰 수 있게 된다.

## 생성자(Constructor)
인스턴스 생성시 실행되어야 할 작업을 하는 특별한 메서드일 뿐 인스턴스를 생성하지 않는다.
이름으로 헷갈리지 말 것! 인스턴스를 생성하는 것은 `new 연산자`이다.
```java
Tv t = new Tv();
```
> 1. 연산자 new에 의해서 힙에 Tv인스턴스가 생성된다.  
> 2. 기본 생성자 Tv()가 수행된다.  
> 3. 연산자 new의 결과로 Tv인스턴스의 주소가 반환되어 참조변수 t에 저장된다.  

### 생성자의 특징
> 메소드 이름은 클래스 이름과 같아야 한다.
> 반환값이 없다.
> 보통 접근제어자는 `public`이지만 `싱글톤 패턴`구현시에 `private`으로 한다.    
>> **싱글톤 패턴**이란 생성자를 `private`으로 지정해놓고 하나의 객체만을 생성하는 `public`메서드를 만들어서 외부에서 오직 하나만 사용할 수 있도록 하는 이론이다.  

### 생성자의 종류
1. 기본 생성자(디폴트 생성자)  
클래스에 정의된 생성자가 없을 경우 컴파일러에 의해 자동으로 추가된다.
```java
public Tv(){}
```  

2. 매개변수가 있는 생성자  
인스턴스 생성과 동시에 매개변수를 초기화 할 수 있다.  
```java
public Tv(int isbn, String name, int price){
    this.isbn = isbn; //this: 자기 자신을 가리키는 참조 변수로 인스턴스의 주소가 저장됨
    this.name = name;
    this.price = price;
}
```
보통 생성자가 여러개인 경우 `오버로딩`을 많이한다.

### this와 this()
1. this
참조변수로 인스턴스 자기 자신을 가리킨다. 현재 객체 자신의 주소가 저장된다.  
주로 인스턴스 변수가 매개변수로 선언된 지역변수의 이름과 같을 때 구분하기 위해 사용한다.  
```java
public Tv(int isbn, String name, int price){
    this.isbn = isbn; 
    this.name = name;
    this.price = price;
}
```

2. this(), this(매개변수)
생성자이며 같은 클래스의 다른 생성자를 호출할 때 사용한다.  
```java
public Tv(){
    this(1234,LG,550000);
}
```

## 멤버변수(속성=필드)  
객체가 존재하는 동안 그 안에 계속 유지되는 변수  

### 선언위치에 따른 변수의 종류
1. 클래스변수(static변수)
인스턴스변수 앞에 static을 붙인다.  
모든 인스턴스가 하나의 저장 공간을 공유하므로 항상 공통된 값을 가진다.  
인스턴스를 생성하지 않고도 `클래스이름.클래스변수`와 같은 형식으로 바로 사용할 수 있다.  
클래스가 메모리에 로딩될 때 단 한번만 수행되며 프로그램이 종료될 때까지 유지된다.  

2. 인스턴스변수
인스턴스가 생성될 때 마다 독립적인 저장공간을 가지기 때문에 서로 다른 값을 가질 수 있다.  
참조변수가 제거되면 가비지 컬렉터에 의해 자동제거된다.  

3. 지역변수
메서드 내에서만 사용 가능하며 메서드가 종료하면 자동으로 소멸되어 사용할 수 없다.  
for문, while문 {}내에 선언된 지역변수도 {}을 벗어나면 소멸되어 사용할 수 없다.

## 메서드(기능) 
어떤 값을 입력하면 이 값으로 작업을 수행해서 결과를 반환`return`한다.  

### 선언위치에 따른 메서드의 종류
1. 클래스 메서드(static메서드)
인스턴스를 생성하지 않고도 `클래스이름.메서드이름(매개변수)`와 같은 형식으로 호출이 가능하다.  

2. 인스턴스 메서드
반드시 인스턴스를 생성해야만 호출할 수 있다.  

> 클래스변수/메서드는 인스턴스 변수/메서드를 사용할 수 없다.
    > 클래스메서드를 호출할 때 인스턴스 메서드가 존재하지 않을 수 있기 때문이다.  
    > 역으로 인스턴스 변수/메서드에서 클래스변수/메서드를 사용하는 것은 이미 메모리에 static변수가 존재하기 때문에 가능하다. 
> 공통된 값을 유지해야 한다면 static을 붙여주자!


### 인자(argument)와 매개변수(parameter)
1. `인자`  
메서드를 호출할 때 괄호()안에 지정해 준 값이다.  
2. `매개변수`
메서드가 작업을 수행하는데 필요한 값들을 제공받기 위한 것으로 `변수의 타입`을 꼭 넣어준다.  
메서드 내에 선언된 것으로 간주되므로 `지역변수`이다.   

### 기본형 매개변수와 참조형 매개변수
1. 기본형 매개변수(Call by value) 
단순히 저장된 값을 읽기만 할 수 있다. (read only)  
2. 참조형 매개변수(Call by Reference)  
저장된 곳의 주소를 알기 때문에 값을 읽고 변경할 수 있다. (read & write)  

### toString()
객체를 만들면 자동으로 생성되나 재정의해서 객체 상태 표현을 커스터마이징할 수 있다.  
디폴트값으로 객체의 주소 정보를 return하지만 `Object클래스`로부터 상속받은 `toString()`을 추가하면 출력 시 객체 이름만 넣어도 멤버변수 값들을 확인할 수 있다.
```java
System.out.println(phone); //phone은 Phone클래스 객체라 가정
```  

<br/>

## JVM의 메모리 구조
응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고, JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.  
메모리영역은 크게 3가지로 나뉜다.  

![jvmmemory](/assets/images/jvmmemory.png)  

1. 메서드 영역(method area)  
프로그램 실행 중 `클래스`가 사용되면 JVM은 해당 클래스 파일을 읽어서 클래스에 대한 정보를 여기에 저장한다.  클래스와 관련된 `클래스변수, static 메서드` 등도 이곳에 생성된다.  

2. 호출스택(call stack)  
`메서드`가 호출되면 필요한 만큼의 메모리가 할당된다.    
이 메모리는 메서드가 작업을 수행하는 동안 `지역 변수(매개변수 포함), 연산의 중간결과` 등을 저장하는데 사용한다.    
메서드가 작업을 마치면 사용했던 메모리를 반환하고 스택에서 제거된다.  
호출 스택의 가장 위에 있는 메서드가 현재 실행 중인 메서드이다.    

3. 힙(heap)  
프로그램 실행 중 모든 `인스턴스 변수`는 여기서 생성된다.   

<br/>

## 가비지 컬렉터(Garbage Collection)  
JVM은 힙에 있는 객체 중 더 이상 사용하지 않는 것들을 체크해서 자동적으로 제거해준다.    
운영체제 입장에서는 단점이기 때문에 최대한 불필요한 객체를 생성하지 말자.  

<br/>

## 패키지(package)
클래스 또는 인터페이스를 포함시킬수 있으며 서로 관련된 클래스끼리 그룹 단위로 묶어 놓음으로써 클래스를 효과적으로 관리할 수 있다.  
마치 파일을 계층적인 구조로 관리하듯 자바의 Class도 package라는 구조를 통해 계층적으로 관리한다.  
package이름은 주로 `도메인의 역순 구조`를 이용한다.  

```java
//naver인 경우
com.naver.erp
```  
위와 같이 점(.)을 구분자로 하여 계층 구조를 구성한다.  
모든 클래스는 반드시 하나의 패키지에 속해야 한다(기본적으로 `이름없는 패키지(unnamed package)`생성됨) 
첫번째 문장에 `package 패키지명`으로 패키지를 선언해주면 된다.  
`java.lang.package`는 Java에서 기본적으로 제공되므로 `System.out.println`와 같은 함수를 바로 사용할 수 있다.

<br/>

## import문
다른 패키지의 클래스를 사용하기 위해 `import`문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 패키지명을 생략하고 클래스이름만 사용할 수 있다.  
```java
import java.util.*;
```
단축키는 `ctrl+shift+o`이다.  


<br/>

## 제어자
클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.  

### 접근제어자(Access Modifier)
접근 범위가 넓은 순은 `public > protected > (default) > private`이다.   
![modifier](/assets/images/modifier.png)  
1. private  
같은 클래스 내에서만 접근 가능  
2. default
같은 패키지 내에서만 접근이 가능  
3. protected
같은 패키지 내에서만 접근 가능하고 상속관계에 있는 자식클래스에서도 접근 가능하다.  
4. public
접근 제한이 전혀 없다.  


### 그외의 제어자
1. static
인스턴스를 생성하지 않고도 사용할 수 있다. 따라서 static메서드의 경우 더 편리하고 속도도 빠르다.  
> 사용될 수 있는 곳: 멤버변수, 메서드, 초기화블록

2. final
변수에 사용하면 값을 변경할 수 없는 `상수`가 되고, 메서드에 사용하면 `오버라이딩`을 할 수 없게 되고 클래스에 사용하면 자신을 확장하는 `자식클래스`를 정의하지 못하게 된다.  
> 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수

3. abstract  
메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상메서드를 선언하는데 사용된다.  
> 사용될 수 있는 곳 - 클래스, 메서드

### 접근제어자의 조합
제어자가 사용될 수 있는 대상을 정리하였다.  
![modifier2](/assets/images/modifier2.png)  
> 메서드에 static과 abstract를 함께 사용할 수 없다.    
→ static은 몸통이 있는 메서드만 사용할 수 있다.  

> 클래스에 abstract와 final을 동시에 사용할 수 없다.  
→ abstract는 상속을 통해 완성되지만 final은 상속할 수 없으므로 서로 모순이다.   

> abstract메서드의 접근 제어자가 private 일 수 없다.  
→ abstract는 상속을 통해 완성되지만 private이면, 외부에 있는 자식 클래스에서 접근할 수 없다.    

> 메서드가 private와 final을 같이 사용할 필요는 없다.  
→ 둘다 상속할 수 없으므로 하나만 적어줘도 된다.    

<br/>

## 오버로딩

<br/>

## 오버라이딩(상속)







