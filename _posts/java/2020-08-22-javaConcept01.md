---
title:  "[Java]"
excerpt: "Java 개념 총정리 01"
permalink: /categories/java/java-Concept01
author_profile: true
categories:
  - Java
toc: true
toc_label: "목차"
toc_icon: "bookmark"
last_modified_at: 2020-08-22
---

자바 공부를 하면서 새로 알게된 개념 & 꼭 필요한 개념 위주로 정리하였음.  

<br/>

# 1. JAVA 배경 지식
## Java의 특징
Write Once, Run Anywhere  
* 자바는 JVM하고만 상호작용을 하기 때문에 OS와 하드웨어에 독립적이라 다른 OS에서도 변경 없이 실행 가능하다. 즉, JVM이 설치된 환경 어느곳이든 동작할 수 있다(크로스 플랫폼)

## Eclipe
Java개발의 대표적인 IDE이며 컴파일, 디버깅, 빌드등의 개발 전체 과정을 편리하게 관리해준다.

## Java 개발환경 구축하기
JDK, IDE다운로드 후 환경변수 설정(JAVA_HOME, Path) 해주고 이클립스 탭메뉴 Preference-Encoding검색하고 utf-8로 변경, html,css,jsp,xml모두 utf-8로 변경
* JDK(Java Development Kit): JVM + JRE, 자바 개발하는데 필요한 프로그램으로 구성
* JVM(Java Virtual Machine): 자바를 실행하기 위한 가상 기계
* JRE(Java Runtime Environment): 자바 실행 환경, 자바로 작성된 프로그램이 실행되기 위한 최소환경

## [Java API 문서](https://docs.oracle.com/javase/8/docs/api/)
클래스 라이브러리의 모든 클래스에 대한 설명이 자세하게 나와 있다.
자바의 사전이라고 생각하면 된다.

## Java 컴파일 과정
Hello.java →(javac.exe 컴파일)→ Hello.class 생성 → (java.exe 실행) → "Hello.world" 출력

<br/>

# 2. 변수
## 변수의 타입
### 1. 기본형(Premitive Type)
실제값을 스택(비싸다, 가깝다)에 저장한다.   
선언하는 동시에 사이즈가 이미 정해져있다.    
종류는 총 8가지가 있다.  
![variable-type](/assets/images/variable-type.png)    

### 2. 참조형(reference Type)
가변적인 공간을 차지한다.
크기가 크기 때문에 별도로 힙(싸다, 멀다)이라는 메모리 공간에 실제 값을 저장하고, 이 주소를 스택에 있는 참조변수에 저장해서 실제 값에 접근한다.

![stringobj](/assets/images/stringobj.png)  
```java
String s1 = "hello";
String s2 = "hello";
String s3 = new String("hello");
String s4 = new String("hello");
System.out.println(s1 == s2);
```
`==`는 두 변수의 메모리 값을 비교한다.  
s1과 s2는 힙의 같은 문자열을 참조하고 있으므로 저장하고 있는 주소값이 같기 때문에 `s1 == s2`는 `true`이다.  
반면에 s3와 s4는 new로 만들어진 다른 문자열을 각각 참조하고 있으므로 저장하고 있는 주소값이 다르기 때문에 `s1 == s2`는 `false`이다.  
문자열의 내용이 같은지 확인하려면 `equals()`를 이용한다.


## 형변환(Type-Casting)
변수 또는 상수의 타입을 다른 타입으로 변환하는 것  
* 작은 타입에 큰 타입으로의 변환은 오류가 발생한다.  
* 정수형은 실수형으로 자동으로 형변환된다.  
* `char타입`은 문자의 유니코드(정수)가 저장되므로 int형에서 char형, char형에서 int형으로 형변환하게 되면 아스키코드표를 기준으로 변환한다.
* boolean을 제외한 나머지 7개 기본형은 서로 형변환이 가능하다.
* 기본형과 참조형은 서로 형변활할 수 없다.

<br/>

#  3. 연산자
연산을 수행하기 위한 기호로 연산을 수행하기 위해서는 반드시 피연산자가 필요하다.  
![operator](/assets/images/operator.png)  

## 비트연산자
피연산자를 비트단위로 논리 연산하며 피연산자로 오로지 정수만 올 수있다.   
피연산자를 이진수로 표현했을 때 |,&,^의 규칙에 따라 연산을 수행한다.  

* I(OR연산자): 피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 이 외에는 0을 얻는다.  
* &(AND연산자): 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다.  
* ^(XOR연산자): 피연산자의 값이 서로 다를 경우에만 1을 결과로 얻는다. 같을때는 1을 얻는다.  
* ~(비트전환연산자): 피연산자를 ~로 표현했을 때, 0은 1로 1은 0으로 바꾼다. 논리부정연산자 '!'와 유사하다.
* <<, >>(쉬프트연산자): 피연산자의 각 자리를 왼쪽(<<)또는 오른쪽(>>)으로 이동한다. 예를 들어 `8<<2`는 피연산자인 10진수 8의 2진수를 왼쪽으로 2자리 이동한다. 이동 후 범위를 벗어난 값은 버려지고, 빈자리는 0으로 채워진다.
* (비교) >>>: 부호를 신경쓰지 않고 오른쪽으로 이동한다.

## 조건연산자 ? :
조건식, 식1, 식2 모두 세개의 피연산자를 필요로 하는 삼항 연산자이다.  
조건식이 true이면 식1이 false이면 식2가 연산 결과가 된다.
```java
result = x > 0 ? 1 : (x == 0 ? = : -1) //이런식으로 중첩 가능
```

<br/>

# Math.random()
0부터 1 **사이**의 랜덤한 실수값을 출력한다.

<br/>

# 4. 배열
**같은 타입**의 여러 변수를 묶음으로 다루는 것
```java
int[] arr; //배열 다루기 위한 참조변수 선언
arr = new int[3]; //실제 저장공간 생성 

int[] arr1 = {1,2,3}; //한줄로 써줘야지 위처럼 두줄로 나누면 에러

int[] arr2 = new int[3];
```

## for each문
**읽기 전용**으로 배열 원소 값을 변경할 수 없다.
```java
int[] arr = {1,2,3};
for(int i : arr) System.out.print(i+" ");//1 2 3
```

## 배열의 복사
배열은 한번 생성하면 그 길이를 변경할 수 없다.(immutable)  
따라서 기존 배열을 기준으로 새로운 배열을 만들고 싶을 때 `System.arraycopy()`를 사용한다.  

```java
int[] arr = {1,2,3};
int[] arr2 = new int[3];
System.arraycopy(arr, 0, arr2, 0, 3); //(기존 배열, 기존 배열 시작 인덱스, 새로운 배열, 새로운 배열 시작 인덱스, 복사할 길이)
```

## 2차원 배열
2차원 배열에서는 마지막 차수의 길이를 지정하지 않고, 추후에 각기 다른 배열을 생성함으로써 가변적인 배열을 생성할 수 있다.  
```java
int[][] arr = new int[5][];
```

<br/>

# 5. 객체지향(OOP)
## 객체지향 특징 4가지
1. 캡슐화(정보은닉) Encapsulation(Information Hiding)

* 접근제어자를 이용한 캡슐화 - setters와 getters

2. 상속 Inheritance
3. 다형성 Polymorphism
4. 추상화 Abstraction

## 클래스와 객체 
1. 클래스
* 현실 세계의 Object들을 분석해서 비슷한 것 끼리 묶어 분류한 것이다.    
다른 정의로는 객체를 정의해 놓은 것으로 객체의 설계도, 틀이다.        
2. 객체    
* 클래스에 정의된 내용대로 메모리에 실제 생성된 것이다.   
* 각 객체가 가지는 속성(정적인 특징)과 기능(동적인 특징)에 따라 다르다.   
* 객체는 클래스의 `인스턴스`라고 부른다.  
* 인스턴스는 `참조변수`를 통해서만 다룰 수 있으며 참조변수의 타입은 인스턴스의 타입과 일치해야한다. 

```java
Tv t; //Tv클래스 타입의 참조변수 t를 선언
t = new TV(); //Tv인스턴스를 생성 후 new연산자의 결과로 Tv인스턴스의 주소가 반환되어 t에 저장한다.
```

<br/>

## 생성자(Constructor)
인스턴스 생성시 실행되어야 할 작업을 하는 특별한 메서드일 뿐 인스턴스를 생성하지 않는다.
이름으로 헷갈리지 말 것! 인스턴스를 생성하는 것은 `new 연산자`이다.
```java
Tv t = new Tv();
```
> 1. 연산자 new에 의해서 힙에 Tv인스턴스가 생성된다.  
> 2. 기본 생성자 Tv()가 수행된다.  
> 3. 연산자 new의 결과로 Tv인스턴스의 주소가 반환되어 참조변수 t에 저장된다.  


객체는 멤버변수와 메서드로 이루어져 있다.
### 멤버변수(속성)  
* `선언위치`에 따른 변수의 종류
1. 클래스변수
2. 인스턴스변수
3. 지역변수

### 메서드(기능) 
어떤 값을 입력하면 이 값으로 작업을 수행해서 결과를 반환한다.  

* `선언위치`에 따른 변수의 종류
1. 클래스 메서드(static메서드)
2. 인스턴스 메서드

* 인자(argument)와 매개변수(parameter)
1. `인자`  
메서드를 호출할 때 괄호()안에 지정해 준 값이다.  
2. `매개변수`
메서드가 작업을 수행하는데 필요한 값들을 제공받기 위한 것으로 `변수의 타입`을 꼭 넣어준다.  
메서드 내에 선언된 것으로 간주되므로 `지역변수`이다.   

* 기본형 매개변수와 참조형 매개변수


* toString()
객체를 만들면 자동으로 생성되나 재정의해서 객체 상태 표현을 커스터마이징할 수 있다.  
디폴트값으로 객체의 주소 정보를 return하지만 `Object클래스`로부터 상속받은 `toString()`을 추가하면 출력 시 객체 이름만 넣어도 멤버변수 값들을 확인할 수 있다.
```java
System.out.println(phone); //phone은 Phone클래스 객체라 가정
```

### 생성자의 특징
> 메소드 이름은 클래스 이름과 같아야 한다.
> 반환값이 없다.
> 보통 접근제어자는 `public`이지만 `싱글톤 패턴`구현시에 `private`으로 한다.    
>> **싱글톤 패턴**이란 생성자를 `private`으로 지정해놓고 하나의 객체만을 생성하는 `public`메서드를 만들어서 외부에서 오직 하나만 사용할 수 있도록 하는 이론이다.  

### 생성자의 종류
1. 기본 생성자(디폴트 생성자)  
클래스에 정의된 생성자가 없을 경우 컴파일러에 의해 자동으로 추가된다.
```java
public Tv(){}
```  

2. 매개변수가 있는 생성자  
인스턴스 생성과 동시에 매개변수를 초기화 할 수 있다.  
```java
public Tv(int isbn, String name, int price){
    this.isbn = isbn; //this: 자기 자신을 가리키는 참조 변수로 인스턴스의 주소가 저장됨
    this.name = name;
    this.price = price;
}
```
보통 생성자가 여러개인 경우 `오버로딩`을 많이한다.

**❤❤뒤에서 변수 메서드에 대한 내용 또 안다루면 여기다가 추가 정리해주기(변수 범위 등등..)**

## 객체 배열
많은 객체를 다룰 때 사용하며 객체 배열안에 객체의 주소가 저장된다.  
선언부(header)와 구현부(body)로 이루어져 있다.

![arrayObject](/assets/images/arrayObject.png)  

```java
Tv[] tvArr = new Tv[3]; //길이가 3인 Tv타입의 참조변수 배열

//★아직 객체가 저장되지 않았다!
for(int i=1; i<-=tvArr.length; i++>{
    tvArr[i] = new tvArr(); //★객체를 생성해서 배열의 각 요소에 저장한다.
    tvArr[i].setPrice(i * 2000);
})
```
`다형성`에 의해 하나의 배열로 여러 종류의 객체를 다룰 수 있게 된다.

## JVM의 메모리 구조
응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고, JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.  
메모리영역은 크게 3가지로 나뉜다.

1. 메서드 영역(method area)  
프로그램 실행 중 `클래스`가 사용되면 JVM은 해당 클래스 파일을 읽어서 클래스에 대한 정보를 여기에 저장한다.  클래스와 관련된 `클래스변수, static 메서드` 등도 이곳에 생성된다.  

2. 호출스택(call stack)  
`메서드`가 호출되면 필요한 만큼의 메모리가 할당된다.    
이 메모리는 메서드가 작업을 수행하는 동안 `지역 변수(매개변수 포함), 연산의 중간결과` 등을 저장하는데 사용한다.    
메서드가 작업을 마치면 사용했던 메모리를 반환하고 스택에서 제거된다.  
호출 스택의 가장 위에 있는 메서드가 현재 실행 중인 메서드이다.    

3. 힙(heap)  
프로그램 실행 중 모든 `인스턴스 변수`는 여기서 생성된다.   

## 가비지 컬렉터(Garbage Collection)  
JVM은 힙에 있는 객체 중 더 이상 사용하지 않는 것들을 체크해서 자동적으로 제거해준다.    
운영체제 입장에서는 단점이기 때문에 최대한 불필요한 객체를 생성하지 말자.  

## 패키지(package)
클래스 또는 인터페이스를 포함시킬수 있으며 서로 관련된 클래스끼리 그룹 단위로 묶어 놓음으로써 클래스를 효과적으로 관리할 수 있다.  
마치 파일을 계층적인 구조로 관리하듯 자바의 Class도 package라는 구조를 통해 계층적으로 관리한다.  
package이름은 주로 `도메인의 역순 구조`를 이용한다.  

```java
//naver인 경우
com.naver.erp
```  
위와 같이 점(.)을 구분자로 하여 계층 구조를 구성한다.  
모든 클래스는 반드시 하나의 패키지에 속해야 한다(기본적으로 `이름없는 패키지(unnamed package)`생성됨) 
첫번째 문장에 `package 패키지명`으로 패키지를 선언해주면 된다.  

## import문
다른 패키지의 클래스를 사용하기 위해 `import`문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 패키지명을 생략하고 클래스이름만 사용할 수 있다.  
```java
import java.util.*;
```
단축키는 `ctrl+shift+o`이다.  

 



