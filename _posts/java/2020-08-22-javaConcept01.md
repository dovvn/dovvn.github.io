---
title:  "[Java]"
excerpt: "Java 개념 총정리 01"
permalink: /categories/java/java-Concept01
author_profile: true
categories:
  - Java
toc: true
toc_label: "목차"
toc_icon: "bookmark"
last_modified_at: 2020-08-22
---

자바 공부를 하면서 새로 알게된 개념 & 꼭 필요한 개념 위주로 정리하였음.  

<br/>

# 1. JAVA 배경 지식
## Java의 특징
Write Once, Run Anywhere  
* 자바는 JVM하고만 상호작용을 하기 때문에 OS와 하드웨어에 독립적이라 다른 OS에서도 변경 없이 실행 가능하다. 즉, JVM이 설치된 환경 어느곳이든 동작할 수 있다(크로스 플랫폼)

## Eclipe
Java개발의 대표적인 IDE이며 컴파일, 디버깅, 빌드등의 개발 전체 과정을 편리하게 관리해준다.

## Java 개발환경 구축하기
JDK, IDE다운로드 후 환경변수 설정(JAVA_HOME, Path) 해주고 이클립스 탭메뉴 Preference-Encoding검색하고 utf-8로 변경, html,css,jsp,xml모두 utf-8로 변경
* JDK(Java Development Kit): JVM + JRE, 자바 개발하는데 필요한 프로그램으로 구성
* JVM(Java Virtual Machine): 자바를 실행하기 위한 가상 기계
* JRE(Java Runtime Environment): 자바 실행 환경, 자바로 작성된 프로그램이 실행되기 위한 최소환경

## [Java API 문서](https://docs.oracle.com/javase/8/docs/api/)
클래스 라이브러리의 모든 클래스에 대한 설명이 자세하게 나와 있다.
자바의 사전이라고 생각하면 된다.

## Java 컴파일 과정
Hello.java →(javac.exe 컴파일)→ Hello.class 생성 → (java.exe 실행) → "Hello.world" 출력

<br/>

# 2. 변수
## 변수의 타입
### 1. 기본형(Premitive Type)
실제값을 스택(비싸다, 가깝다)에 저장한다.   
선언하는 동시에 사이즈가 이미 정해져있다.    
종류는 총 8가지가 있다.  
![variable-type](/assets/images/variable-type.png)    

### 2. 참조형(reference Type)
가변적인 공간을 차지한다.
크기가 크기 때문에 별도로 힙(싸다, 멀다)이라는 메모리 공간에 실제 값을 저장하고, 이 주소를 스택에 있는 참조변수에 저장해서 실제 값에 접근한다.

![stringobj](/assets/images/stringobj.png)  
```java
String s1 = "hello";
String s2 = "hello";
String s3 = new String("hello");
String s4 = new String("hello");
System.out.println(s1 == s2);
```
`==`는 두 변수의 메모리 값을 비교한다.  
s1과 s2는 힙의 같은 문자열을 참조하고 있으므로 저장하고 있는 주소값이 같기 때문에 `s1 == s2`는 `true`이다.  
반면에 s3와 s4는 new로 만들어진 다른 문자열을 각각 참조하고 있으므로 저장하고 있는 주소값이 다르기 때문에 `s1 == s2`는 `false`이다.  
문자열의 내용이 같은지 확인하려면 `equals()`를 이용한다.


## 형변환(Type-Casting)
변수 또는 상수의 타입을 다른 타입으로 변환하는 것  
* 작은 타입에 큰 타입으로의 변환은 오류가 발생한다.  
* 정수형은 실수형으로 자동으로 형변환된다.  
* `char타입`은 문자의 유니코드(정수)가 저장되므로 int형에서 char형, char형에서 int형으로 형변환하게 되면 아스키코드표를 기준으로 변환한다.
* boolean을 제외한 나머지 7개 기본형은 서로 형변환이 가능하다.
* 기본형과 참조형은 서로 형변활할 수 없다.

<br/>

# 3. 연산자
연산을 수행하기 위한 기호로 연산을 수행하기 위해서는 반드시 피연산자가 필요하다.  
![operator](/assets/images/operator.png)  

## 비트연산자
피연산자를 비트단위로 논리 연산하며 피연산자로 오로지 정수만 올 수있다.   
피연산자를 이진수로 표현했을 때 |,&,^의 규칙에 따라 연산을 수행한다.  

* I(OR연산자): 피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 이 외에는 0을 얻는다.  
* &(AND연산자): 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다.  
* ^(XOR연산자): 피연산자의 값이 서로 다를 경우에만 1을 결과로 얻는다. 같을때는 1을 얻는다.  
* ~(비트전환연산자): 피연산자를 ~로 표현했을 때, 0은 1로 1은 0으로 바꾼다. 논리부정연산자 '!'와 유사하다.
* <<, >>(쉬프트연산자): 피연산자의 각 자리를 왼쪽(<<)또는 오른쪽(>>)으로 이동한다. 예를 들어 `8<<2`는 피연산자인 10진수 8의 2진수를 왼쪽으로 2자리 이동한다. 이동 후 범위를 벗어난 값은 버려진다.  
빈자리는 `최상위부호`와 같은 값으로 채워진다.  
* (비교) >>>: 부호를 신경쓰지 않고 오른쪽으로 이동한다.

## 조건연산자 ? :
조건식, 식1, 식2 모두 세개의 피연산자를 필요로 하는 삼항 연산자이다.  
조건식이 true이면 식1이 false이면 식2가 연산 결과가 된다.
```java
result = x > 0 ? 1 : (x == 0 ? = : -1) //이런식으로 중첩 가능
```

## &,|과 &&,||
### 1. &과 |
`A | B | C`와 `A & B & C`는 모두 판단한다.  

### 2. &&과 ||
`A && B && C`과 `A || B || C`는 순차적으로 파악해서 앞에서 거짓이면 나머지는 판단하지 않는다.

<br/>

# 4. 조건문
## if문
조건식이 참이면 {}안의 문장을 수행한다.  

## switch문
switch문의 결과로 `double`형을 뺀 `정수` 또는 `문자열`만 올 수 있다.
break문을 빼먹지 말자!  

<br/>

# 5. 반복문
## for문
예측 가능한 반복일때 사용한다.    
index의 증감을 활용한다.  
독립된 Block으로 존재한다.  

## while문
예측이 가변적인 반복일때 사용한다.  
index보다는 break, continue문을 활용한다.  

* break문
반복문을 종료한다.
* continue문
해당 조건만 건너뛰고 바로 다음 반복문을 수행한다.

## do-while문
처음부터 한번은 수행하고 시작한다.  

<br/>

# 6. 배열
**같은 타입**의 여러 변수를 묶음으로 다루는 것
```java
int[] arr; //배열 다루기 위한 참조변수 선언
arr = new int[3]; //실제 저장공간 생성 

int[] arr1 = {1,2,3}; //한줄로 써줘야지 위처럼 두줄로 나누면 에러

int[] arr2 = new int[3];
```

## for each문
**읽기 전용**으로 배열 원소 값을 변경할 수 없다.
```java
int[] arr = {1,2,3};
for(int i : arr) System.out.print(i+" ");//1 2 3
```

## 배열의 복사
배열은 한번 생성하면 그 길이를 변경할 수 없다.(immutable)  
따라서 기존 배열을 기준으로 새로운 배열을 만들고 싶을 때 `System.arraycopy()`를 사용한다.  

```java
int[] arr = {1,2,3};
int[] arr2 = new int[3];
System.arraycopy(arr, 0, arr2, 0, 3); //(기존 배열, 기존 배열 시작 인덱스, 새로운 배열, 새로운 배열 시작 인덱스, 복사할 길이)
```

## 2차원 배열
2차원 배열에서는 마지막 차수의 길이를 지정하지 않고, 추후에 각기 다른 배열을 생성함으로써 가변적인 배열을 생성할 수 있다.  
```java
int[][] arr = new int[5][];
```

<br/>

# 7. 객체지향(OOP)
## 객체지향 특징 4가지
**1. 캡슐화(정보은닉)(Encapsulation(Information Hiding))**  
외부로 부터 데이터를 보호하기 위해서 또는, 내부적으로만 사용되는 멤버들을 클래스 내부에 감추기 위해서 `접근제어자`를 사용한다.  

* **접근제어자를 이용한 캡슐화 - setters와 getters**  
클래스의 `멤버변수`는 `private`으로 제한하고 멤버변수의 값을 읽고 변경할 수 있는 `public 메소드`를 만들어서 멤버변수의 값을 간접적으로 다룰 수 있도록 한다.  
> 멤버변수에 접근하기 위해서는 클래스 외부에서 `인스턴스`를 생성한 후, public으로 만든 setter()메서드로 값을 변경하고 값을 가져오고 싶을 경우 public으로 만든 getter()메서드를 사용한다.  

```java
Tv tv = new Tv();
tv.getPrice(); //가격변수 가져오기
tv.setPrice(5000); //가격변수 변경하기
```  

**2. 상속(Inheritance)**
기존의 클래스를 재사용하여 새로운 클래스를 작성한다.  
상속을 해주는 클래스를 `부모클래스, 상위클래스, 슈퍼클래스`라고 한다.  
상속을 받는 클래스를 `자식클래스, 하위클래스, 서브클래스`라고 한다.  
키워드 `extends`를 사용해서 부모 클래스의 `멤버 변수(필드)`와 `메서드`를 상속받는다.   

```java
class Tv extends Product{
...
}
```  

* 자식클래스가 하나의 부모클래스만 받는 `단일 상속`만 가능하다!!  
* 반대로 부모 클래스는 여러 자식클래스에게 상속이 가능하다.  
* 부모클래스는 자식클래스에서 정의한 필드와 메서드를 사용할 수 없다.  
* 부모클래스에서 정의된 static메서드를 자식 클래스에서 똑같은 이름의 static메서드로 정의할 수 있다.  
→ 하지만 각 클래스에 별개의 static메서드를 정의한것일 뿐 오버라이딩은 아니다!!  
→ 각 메서드는 클래스이름으로 구분하여 `클래스이름.메서드이름()`으로 호출한다.  
→ static멤버들은 자신들이 정의된 클래스에 묶여있다고 생각하자!!  

상속되지 않는 경우,
* 생성자와 초기화 블럭은 상속되지 않는다.
* `부모클래스`의 `static 메소드`는 상속되지 않는다.
* 접근제어자가 `private`인 멤버는 상속 불가능하고, 패키지가 다를 경우 접근제어자가 `default`인 경우도 상속이 불가능하다.  
→ 캡슐화를 적용해서 멤버변수는 `private`이나 `protected`로 하되, `public`메소드를 통해서 접근하자.  

**3. 다형성(Polymorphism)**  
하나의 이름으로 여러개의 형태를 구성할 수 있는 것  
크게 Method와 Type으로 나눌 수 있다.  

## Method  
### 오버로딩  
이름이 같아도 파라미터가 다르면 별개의 메소드로 간주한다.  

### 오버라이딩  
상속관계에서 자식클래스가 부모클래스의 메소드를 똑같이 `재정의`할 수 있다.  

## Type  
부모클래스 타입의 참조변수로 자식클래스의 인스턴스를 참조할 수 있다.  
반대로 자식클래스 타입의 참조변수로 부모클래스의 인스턴스를 참조할 수 없다.  


**4. 추상화(Abstraction)**   
### 추상클래스   
클래스이지만 추상메서드를 가지고 스스로 인스턴스를 생성할 수 없다.   
오직 `상속`을 통해서 `자식클래스`에 의해서만 완성될 수 있다.   
추상클래스를 상속받는 클래슨느 **반드시** 추상 메소드를 구현해야 한다.      
```java  
abstract class 클래스이름 {
    ...
}  
```  

* **추상메서드**  
선언부만 작성하고 구현부는 작성하지 않은 메서드  
```java  
public void doing(){ //선언부
    ...//구현부
}
```  

* **디폴트 메서드**  
jdk1.8부터 추가되었으며 추상메서드의 기본적인 구현을 제공하는 메서드로, 추상메서드가 아니기 때문에 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.  
접근제어자는 `public`이고 생략 가능하다.  

```java
interface MyInterface{
    void method();
    default void newMethod(){}; //몸통{}이 있음
}
```

### 인터페이스  
일종의 추상클래스이며 추상클래스보다 추상도가 높아 오직 `추상메서드`와 `상수`만을 멤버로 갖는다.   
클래스가 인터페이스를 상속받을 때는 키워드 `implements`를 사용한다.  
* 모든 멤버변수는 `public static final`이어야 하며, 이를 생략할 수 있다.  
* 모든 메서드는 `public abstract`이어야 하며, 이를 생략할 수 있다(단, static메서드와 디폴트메서드는 예외이다 - jdk1.8부터)   

```java  
interface 인터페이스이름{
    public static final 타입 상수이름 = 값;  
    public abstract 메서드이름(매개변수목록);
}
```  

* **인터페이스의 상속**      
인터페이스는 인터페이스로부터만 상속받을 수 있고 클래스와 다르게 `다중 상속`이 가능하다.  
```java
interface A {
    void doingA();
}

interface B {
    void doingB();
}

interface C extends A, B {
    
}
```  

## 클래스와 객체  
**1. 클래스**
* 현실 세계의 Object들을 분석해서 비슷한 것 끼리 묶어 분류한 것이다.    
다른 정의로는 객체를 만들기 위한 설계도이다. `필드(멤버변수)`부분과 `메소드` 부분으로 설계된다.  

**2. 객체**    
* 클래스에 정의된 내용대로 메모리에 실제 생성된 것이다.   
* 객체는 클래스의 `인스턴스`라고 부른다.   
* 인스턴스는 `참조변수`를 통해서만 다룰 수 있으며 참조변수의 타입은 인스턴스의 타입과 일치해야한다.  

```java
Tv t; //Tv클래스 타입의 참조변수 t를 선언
t = new TV(); //Tv인스턴스를 생성 후 new연산자의 결과로 Tv인스턴스의 주소가 반환되어 t에 저장한다.
```

## 객체 배열
많은 객체를 다룰 때 사용하며 객체 배열안에 객체의 주소가 저장된다.  

![arrayObject](/assets/images/arrayObject.png)  

```java
Tv[] tvArr = new Tv[3]; //길이가 3인 Tv타입의 참조변수 배열

//아직 객체가 저장되지 않았다!
for(int i=1; i<-=tvArr.length; i++>{
    tvArr[i] = new tvArr(); //★객체를 생성해서 배열의 각 요소에 저장한다.
    tvArr[i].setPrice(i * 2000);
})
```
`다형성`에 의해 하나의 배열로 여러 종류의 객체를 다룰 수 있게 된다.

## 변수와 메서드  
### **1. 변수**   
`선언위치`에 따라 `멤버변수`와 `지역변수`로 나눌 수 있다.  
![variables1](/assets/images/variables1.png)  

**멤버변수**  
* **클래스변수(static변수)**  
인스턴스변수 앞에 `static`을 붙인다.  
모든 인스턴스가 `하나의 저장 공간`을 공유하므로 `항상 공통된 값`을 가진다.  
인스턴스를 생성하지 않고도 `클래스이름.클래스변수`와 같은 형식으로 바로 사용할 수 있다.  
> 생명주기    
>   >`프로그램`이 시작될 때 생성, `프로그램` 종료되면 소멸    

* **인스턴스변수**      
`인스턴스`가 생성될 때 마다 `독립적인 저장공간`을 가지기 때문에 서로 다른 값을 가질 수 있다.  
`참조변수`가 제거되면 `가비지 컬렉터`에 의해 자동제거된다.  
> 생명주기    
>   >`인스턴스`가 생성될 때 생성, 그 인스턴스를 참조하고 있는 `참조변수`가 없으면 소멸 

**지역변수**    
클래스 이외의 영역인 `메서드, 생성자, 초기화블럭` 내에서만 사용 가능하며 메서드가 종료하면 자동으로 소멸되어 사용할 수 없다.  
`for문, while문` {}내에 선언된 지역변수도 {}을 벗어나면 소멸되어 사용할 수 없다.
> 생명주기    
>   >`메서드`가 호출될때 생성되고 `메서드`가 종료하면 소멸  

### **2. 메서드(기능)**   
어떤 값을 입력하면 이 값으로 작업을 수행해서 결과를 반환`return`한다.  
반환값이 없으면 `return;`만 적어준다.  

메서드도 `선언위치`에 따라 `클래스(static)메서드`와 `인스턴스메서드`로 나눌 수 있다.  

* **클래스 메서드(static메서드)**  
인스턴스를 생성하지 않고도 `클래스이름.메서드이름(매개변수)`와 같은 형식으로 호출이 가능하다.  

* **인스턴스 메서드**  
반드시 `인스턴스`를 생성해야만 호출할 수 있다.  

`클래스변수/메서드`는 `인스턴스 변수/메서드`를 사용할 수 없다.  
> 클래스메서드를 호출할 때 인스턴스 메서드가 존재하지 않을 수 있기 때문이다.    
> 역으로 인스턴스 변수/메서드에서 클래스변수/메서드를 사용하는 것은 이미 메모리에 static변수가 존재하기 때문에 가능하다.  
> 공통된 값을 유지해야 한다면 **static**을 붙여주자!  

**인자(argument)와 매개변수(parameter)**
* **인자**    
메서드를 호출할 때 `괄호()`안에 지정해 준 값이다.    
* **매개변수**  
메서드가 작업을 수행하는데 필요한 값들을 제공받기 위한 것으로 `변수의 타입`을 꼭 넣어준다.  
메서드 내에 선언된 것으로 간주되므로 `지역변수`이다.   

**기본형 매개변수와 참조형 매개변수**
* **기본형 매개변수(Call by value)**       
단순히 저장된 값을 읽기만 할 수 있다. `(read only)`  
* **참조형 매개변수(Call by Reference)**      
저장된 곳의 주소를 알기 때문에 값을 읽고 변경할 수 있다. `(read & write)`  

### **toString()**  
객체를 만들면 자동으로 생성되나 재정의해서 객체 상태 표현을 커스터마이징할 수 있다.  
디폴트값으로 객체의 주소 정보를 return하지만 `Object클래스`로부터 상속받은 `toString()`을 추가하면 출력 시 객체 이름만 넣어도 멤버변수 값들을 확인할 수 있다.
```java
System.out.println(phone); //phone은 Phone클래스 객체라 가정
```  

### Math.random()
0부터 1 **사이**의 랜덤한 실수값을 출력한다.

## 생성자(Constructor)
인스턴스 생성시 실행되어야 할 작업을 하는 특별한 메서드일 뿐 인스턴스를 생성하지 않는다.
이름으로 헷갈리지 말 것! 인스턴스를 생성하는 것은 `new 연산자`이다.
```java
Tv t = new Tv();
```
> 1. 연산자 new에 의해서 힙에 Tv인스턴스가 생성된다.  
> 2. 기본 생성자 Tv()가 수행된다.  
> 3. 연산자 new의 결과로 Tv인스턴스의 주소가 반환되어 참조변수 t에 저장된다.  

### 생성자의 특징
* 메소드 이름은 클래스 이름과 같아야 한다.
* 반환값이 없다.
* 보통 접근제어자는 `public`이지만 `싱글톤 패턴`구현시에 `private`으로 한다.    
> **싱글톤 패턴**이란 생성자를 `private`으로 지정해놓고 하나의 객체만을 생성하는 `public`메서드를 만들어서 외부에서 오직 하나만 사용할 수 있도록 하는 이론이다.  

### 생성자의 종류
**1. 기본 생성자(디폴트 생성자)**  
클래스에 정의된 생성자가 없을 경우 컴파일러에 의해 자동으로 추가된다.
```java
public Tv(){}
```  

**2. 매개변수가 있는 생성자**  
인스턴스 생성과 동시에 매개변수를 초기화 할 수 있다.  
```java
public Tv(int isbn, String name, int price){
    this.isbn = isbn; //this: 자기 자신을 가리키는 참조 변수로 인스턴스의 주소가 저장됨
    this.name = name;
    this.price = price;
}
```
보통 생성자가 여러개인 경우 `오버로딩`을 많이한다.

### this와 this()
**1. this**  
`참조변수`로 `인스턴스 자기 자신`을 가리킨다. 현재 `객체 자신의 주소`가 저장된다.  
주로 인스턴스 변수가 매개변수로 선언된 지역변수의 이름과 같을 때 구분하기 위해 사용한다.  
`static메서드`에서 사용할 수 없다.  
```java
public Tv(int isbn, String name, int price){
    this.isbn = isbn; 
    this.name = name;
    this.price = price;
}
```

**2. this(), this(매개변수)**  
`생성자`이며 같은 클래스의 다른 생성자를 호출할 때 사용한다.  
```java
public Tv(){
    this(1234,LG,550000);
}
```

## 변수의 초기화  
### 변수의 초기화  
`멤버변수(클래스변수와 인스턴스변수)`와 배열의 초기화는 선택적이지만, `지역변수`의 초기화는 필수적이다.  

### 명시적 초기화
변수를 선언과 동시에 초기화하는 것  
이보다 복잡한 초기화 작업에는 `초기화 블럭`또는 `생성자`사용한다.  

### 초기화 블럭
**1. 클래스 초기화 블럭**    
클래스변수의 복잡한 초기화에 사용된다.  
* **초기화시점**   
클래스가 `메모리`에 로딩될때 `한번만`수행  

```java
static{
    ...
}
```  

**2. 인스턴스 초기화 블럭**    
인스턴스변수의 복잡한 초기화에 사용된다.  
* **초기화시점**    
생성자와 같이 `인스턴스`를 생성할때마다 수행    
```java
{
    ...
}
```  

### 멤버변수의 초기화 순서  
**클래스변수 초기화**(기본값 → 명시적초기화 → 클래스 초기화 블럭)  → **인스턴스변수 초기화**(기본값 → 명시적초기화 → 인스턴스 초기화 블럭) → **생성자**  

## 오버로딩(Overloading)  
상속 관계 신경 X  
한 클래스 내에 이름이 여러개인 메서드를 여러개 정의하는 것     
> 메서드 `이름`이 같아야 한다.  
> 반드시 `매개변수의 개수 또는 타입`이 달라야 한다.  


## JVM의 메모리 구조
응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고, JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.  
메모리영역은 크게 **3가지**로 나뉜다.  

![jvmmemory](/assets/images/jvmmemory.png)  


**1. 메서드 영역(method area)**    
프로그램 실행 중 `클래스`가 사용되면 JVM은 해당 클래스 파일을 읽어서 클래스에 대한 정보를 여기에 저장한다.  클래스와 관련된 `클래스변수, static 메서드` 등도 이곳에 생성된다.  

**2. 호출스택(call stack)**    
`메서드`가 호출되면 필요한 만큼의 메모리가 할당된다.    
이 메모리는 메서드가 작업을 수행하는 동안 `지역 변수(매개변수 포함), 연산의 중간결과` 등을 저장하는데 사용한다.    
메서드가 작업을 마치면 사용했던 메모리를 반환하고 스택에서 제거된다.  
호출 스택의 가장 위에 있는 메서드가 현재 실행 중인 메서드이다.    

**3. 힙(heap)**    
프로그램 실행 중 모든 `인스턴스 변수`는 여기서 생성된다.   


## 가비지 컬렉터(Garbage Collection)  
JVM은 힙에 있는 객체 중 더 이상 사용하지 않는 것들을 체크해서 자동적으로 제거해준다.    
운영체제 입장에서는 단점이기 때문에 최대한 불필요한 객체를 생성하지 말자.  


## 패키지(package)
클래스 또는 인터페이스를 포함시킬수 있으며 서로 관련된 클래스끼리 그룹 단위로 묶어 놓음으로써 클래스를 효과적으로 관리할 수 있다.  
마치 파일을 계층적인 구조로 관리하듯 자바의 Class도 package라는 구조를 통해 계층적으로 관리한다.  
package이름은 주로 `도메인의 역순 구조`를 이용한다.  

```java
//naver인 경우
com.naver.erp
```  
위와 같이 점(.)을 구분자로 하여 계층 구조를 구성한다.  
모든 클래스는 반드시 하나의 패키지에 속해야 한다(기본적으로 `이름없는 패키지(unnamed package)`생성됨) 
첫번째 문장에 `package 패키지명`으로 패키지를 선언해주면 된다.  
`java.lang.package`는 Java에서 기본적으로 제공되므로 `System.out.println`와 같은 함수를 바로 사용할 수 있다.


## import문
다른 패키지의 클래스를 사용하기 위해 `import`문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 패키지명을 생략하고 클래스이름만 사용할 수 있다.  
```java
import java.util.*;
```
단축키는 `ctrl+shift+o`이다.  


## 제어자
클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.  
제어자는 크게 `접근제어자`와 `그 외의 제어자`로 나눌 수 있다.   

### 접근제어자(Access Modifier)  
접근 범위가 넓은 순은 `public > protected > (default) > private`이다.     
![modifier](/assets/images/modifier.png)    
**1. private**    
같은 클래스 내에서만 접근 가능  
**2. default**  
같은 패키지 내에서만 접근이 가능  
**3. protected**  
같은 패키지 내에서만 접근 가능하고 상속관계에 있는 자식클래스에서도 접근 가능하다.  
**4. public**  
접근 제한이 전혀 없다.  


### 그외의 제어자
**1. static**  
인스턴스를 생성하지 않고도 사용할 수 있다. 따라서 static메서드의 경우 더 편리하고 속도도 빠르다.  
> 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화블록

**2. final**  
변수에 사용하면 값을 변경할 수 없는 `상수`가 되고, 메서드에 사용하면 `오버라이딩`을 할 수 없게 되고 클래스에 사용하면 자신을 확장하는 `자식클래스`를 정의하지 못하게 된다.  
> 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수

**3. abstract**    
메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상메서드를 선언하는데 사용된다.  
> 사용될 수 있는 곳 - 클래스, 메서드

### 접근제어자의 조합
제어자가 사용될 수 있는 대상을 정리하였다.  
![modifier2](/assets/images/modifier2.png)    

* 메서드에 `static`과 `abstract`를 함께 사용할 수 없다.    
→ static은 몸통이 있는 메서드만 사용할 수 있다.  

* 클래스에 `abstract`와 `final`을 동시에 사용할 수 없다.  
→ abstract는 상속을 통해 완성되지만 final은 상속할 수 없으므로 서로 모순이다.   

* abstract메서드의 접근 제어자가 `private` 일 수 없다.  
→ abstract는 상속을 통해 완성되지만 private이면, 외부에 있는 자식 클래스에서 접근할 수 없다.    

* 메서드가 `private`와 `final`을 같이 사용할 필요는 없다.  
→ 둘다 상속할 수 없으므로 하나만 적어줘도 된다.    


## Object클래스  
모든 클래스 상속계층도의 최상위에 있는 조상 클래스  
Java의 모든 클래스들은 Objec클래스의 멤버들을 상속받기 때문에 Object클래스에 정의된 멤버들을 사용할 수 있다.  


## 오버라이딩(Overriding)
상속 관계 신경 O  
조상 클래스로부터 상속받은 메서드의 내용을 변경한다.  
`@Overriding` 어노테이션을 사용해서 부모클래스의 특정 메서드를 재정의한다고 `컴파일러`에게 명시한다.  

**자식클래스에서 오버라이딩하는 메서드**는 조상클래스 메서드와  
* `이름`이 같아야한다.  
* `매개변수`가 같아야 한다.  
* `반환타입`이 같아야 한다.  
* `접근제어자`를 조상클래스의 메서드보다 `좁은 범위`로 변경할 수 없다.  
* `예외`는 조상클래스의 메서드보다 `많이` 선언할 수 없다.  
* `인스턴스메서드`를 `static메서드`로 또는 그 반대로 변경할 수 없다.  

## super과 super()
### 1. super
super은 부모 객체의 주소를 저장한다.  
`this`와 마찬가지로 `static메서드`에서는 사용할 수 없다.  
부모의 멤버변수가 `private`인 경우 `this.public메소드()`를 사용해서 접근할때 많이 쓰인다.  

```java
class Product{
    private int price = 3000;
    public int getPrice(){
        return this.name;
    }
    ...
}

class Tv extends Product{
    ...
    public void show(){
        String info = super.getPrice()+"...";
    }
    ...
}
```  

### 2. super()과 super(매개변수)
조상클래스의 `생성자`이다.  
자식클래스의 생성자는 `첫 줄`에 반드시 `super()`를 사용해서 부모 생성자를 먼저 호출해야한다.  
그렇지 않으면 컴파일러가 자동적으로 `super();`를 생성자의 첫줄에 삽입한다.    
→ 자식클래스의 멤버가 조상클래스의 멤버를 사용할 수 있으므로 조상의 멤버들이 먼저 초기화 되어 있어야 한다.    

## 내부클래스  
클래스 내에 선언된 클래스  
* 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.  
* 코드의 복잡성을 줄일 수 있다. (캠슐화)  

### 1. local  
클래스 안에서 다시 정의되는 클래스  
별도의 객체가 만들어진다.  

### 2. anonymoust  
클래스안에서 이름이 없이 만들어지는 클래스  
재사용되지 않고 한번 사용된다.  

### 3. static
클래스안에서 다시 정의되는 클래스
별도의 객체를 만들지 않고도 사용할 수 있다.  


